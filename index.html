<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake</title>
    <style>
        /* --- General Setup & Theming --- */
        :root {
            --bg-color: #121212;
            --primary-text: #e0e0e0;
            --border-color: #00ffff;
            --snake-head: #ff00ff;
            --snake-body: #00ff00;
            --obstacle-color: Red;
            --accent-color: #ff7f50;
        }

        body {
            color: var(--primary-text);
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
        }

        /* --- Background Grid Effect --- */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: -1;
            background-image: url("data:image/svg+xml,<svg width='40' height='40' xmlns='http://www.w3.org/2000/svg'><rect width='40' height='40' fill='%23030328'/><path d='M40 0v40H0' fill='none' stroke='%2300d1ff' stroke-width='0.5'/></svg>");
            background-size: 40px;
            background-repeat: repeat;
            background-position: top;
            opacity: 0.90;
            filter: blur(0px);
        }
        
        /* --- Game & UI Layout --- */
        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        canvas {
            background-color: #000;
            border: 4px solid var(--border-color);
            box-shadow: 0 0 20px var(--border-color);
        }

        #ui-top {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 100px;
            font-size: 1.7em;
            text-shadow: 2px 2px var(--snake-head);
            z-index: 10;
        }

        /* --- Overlays (Start/Game Over) --- */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.2);
            display: none; /* Hidden by default */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 20;
        }

        .overlay.visible {
            display: flex;
        }

        .overlay h1 {
            font-size: 5em;
            color: var(--border-color);
            text-shadow: 4px 4px var(--snake-head);
            margin-bottom: 30px;
        }

        .overlay h2 {
            font-size: 2.5em;
            color: var(--accent-color);
            text-shadow: 3px 3px var(--bg-color);
            margin-bottom: 20px;
        }

        /* --- Buttons & Inputs --- */
        button {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.2em;
            padding: 15px 30px;
            margin: 10px;
            border: 2px solid var(--primary-text);
            background-color: transparent;
            color: var(--primary-text);
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            border-radius: 12px;
            width: 300px;
        }

        button:hover {
            background-color: var(--accent-color);
            color: var(--bg-color);
            border-color: var(--accent-color);
            box-shadow: 0 0 15px var(--accent-color);
        }

        #player-name-input {
            font-family: 'Courier New', Courier, monospace;
            text-align: center;
            font-size: 1.2em;
            padding: 10px;
            margin: 10px 0;
            width: 250px;
            background-color: var(--bg-color);
            border: 2px solid var(--border-color);
            color: var(--primary-text);
            text-transform: uppercase;
        }

        #player-name-input::placeholder {
            color: #666;
        }
        
        /* --- Highscore Section --- */
        #highscore-section {
            position: absolute;
            right: 20px;
            top: 20px;
            bottom: 20px;
            width: 280px;
            text-align: left;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        #highscore-section h3 {
            color: var(--border-color);
            text-align: left;
            margin-bottom: 15px;
            font-size: 1.7em;
        }

        #highscore-list {
            list-style-type: decimal;
            padding-left: 25px;
            font-size: 1.2em;
            line-height: 1.8;
            overflow-y: auto;
            flex-grow: 1;
        }

        #highscore-list li {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 10px;
            margin-bottom: 5px;
        }

        #highscore-list .score {
            color: var(--obstacle-color);
            font-weight: bold;
        }

        #highscore-list .date {
            color: var(--primary-text);
            opacity: 0.7;
        }

        /* --- How to Play Modal --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: var(--bg-color);
            padding: 40px;
            border: 4px solid var(--border-color);
            box-shadow: 0 0 20px var(--border-color);
            max-width: 600px;
            position: relative;
            line-height: 1.8;
        }
        
        .close-button {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 30px;
            cursor: pointer;
            color: var(--primary-text);
        }

        .close-button:hover {
            color: var(--accent-color);
        }

        .modal-content ul {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }

        .modal-content li {
            margin-bottom: 10px;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="game-container">
        
        <div id="ui-top">
            <div id="score-container">SCORE: <span id="score-value">0</span></div>
            <div id="level-container">LEVEL: <span id="level-value">1</span></div>
        </div>

        <canvas id="game-canvas"></canvas>

        <div id="start-screen" class="overlay visible">
            <h1><big>SNAKE</big></h1>
            <button id="start-button">START GAME</button>
            <button id="how-to-play-button">HOW TO PLAY</button>
        </div>

        <div id="game-over-screen" class="overlay">
            <h2>GAME OVER</h2>
            <p>Your score: <span id="final-score">0</span></p>
            <div id="new-highscore-input-container" class="hidden">
                <p>üèÜ NEW HIGHSCORE! üèÜ</p>
                <input type="text" id="player-name-input" placeholder="NAME? (MAX 8 CHARS)" maxlength="8">
                <button id="submit-score-button">SUBMIT</button>
            </div>
            <button id="play-again-button">PLAY AGAIN</button>
        </div>

    </div>

    <div id="highscore-section">
        <h3>Your Highscores</h3>
        <ol id="highscore-list"></ol>
    </div>

    <div id="how-to-play-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <span id="close-modal" class="close-button">√ó</span>
            <h2>HOW TO PLAY</h2>
            <p>Use <strong>ARROW KEYS</strong> or <strong>W, A, S, D</strong> to control the snake.</p>
            <ul>
                <li>Eat food to grow longer and earn points.</li>
                <li>üçé Apple: +1 length, +10 points</li>
                <li>üçí Cherry: +3 length, +50 points</li>
                <li>üçá Grape: No length, +100 points, temporary speed boost!</li>
            </ul>
            <p>The game ends if you hit the walls, an obstacle, or your own tail.</p>
            <p>The difficulty increases with each level. Good luck! üòâ</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            'use strict';

            // --- Constants & Configuration ---
            const GRID_SIZE = 20; // The number of cells in the grid (width and height)
            const BASE_MOVE_INTERVAL = 500; // Initial time in ms between snake moves
            const SPEED_INCREASE_PER_LEVEL = 10; // How much faster the snake gets per level (in ms)
            const MIN_MOVE_INTERVAL = 50; // The fastest the snake can move
            const POINTS_PER_LEVEL = 150; // How many points are needed to level up
            const SPEED_BOOST_DURATION = 5000; // Duration of grape speed boost in ms
            const OBSTACLES_PER_LEVEL = 2; // Number of new obstacles added each level
            const GRAPE_CHANCE = 0.05; // 5% chance to spawn a grape (after level 3)
            const CHERRY_CHANCE = 0.2; // 20% chance to spawn a cherry
            const FOOD_TYPES = {
                APPLE: { emoji: 'üçé', points: 10, growth: 1, action: null },
                CHERRY: { emoji: 'üçí', points: 50, growth: 3, action: null },
                GRAPE: { emoji: 'üçá', points: 100, growth: 0, action: 'speedBoost' },
            };
            const HIGHSCORE_KEY = 'snakeHighScores_v2'; // Key for localStorage
            const MAX_HIGHSCORES = 10; // Maximum number of highscores to store

            // --- DOM Element References ---
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const scoreValue = document.getElementById('score-value');
            const levelValue = document.getElementById('level-value');
            const startScreen = document.getElementById('start-screen');
            const gameOverScreen = document.getElementById('game-over-screen');
            const finalScore = document.getElementById('final-score');
            const newHighscoreContainer = document.getElementById('new-highscore-input-container');
            const playerNameInput = document.getElementById('player-name-input');
            const highscoreList = document.getElementById('highscore-list');
            const startButton = document.getElementById('start-button');
            const howToPlayButton = document.getElementById('how-to-play-button');
            const playAgainButton = document.getElementById('play-again-button');
            const submitScoreButton = document.getElementById('submit-score-button');
            const howToPlayModal = document.getElementById('how-to-play-modal');
            const closeModalButton = document.getElementById('close-modal');
            
            // --- CSS Color References ---
            const style = getComputedStyle(document.documentElement);
            const SNAKE_HEAD_COLOR = style.getPropertyValue('--snake-head').trim();
            const SNAKE_BODY_COLOR = style.getPropertyValue('--snake-body').trim();
            const OBSTACLE_COLOR = style.getPropertyValue('--obstacle-color').trim();

            // --- Game State Variables ---
            let canvasSize, cellSize;
            let snake, food, direction, nextDirection, obstacles, score, level;
            let gameOver, gameStarted, gameLoopId;
            let highScores = [];
            let lastTime = 0;
            let moveTimer = 0;
            let currentMoveInterval = BASE_MOVE_INTERVAL;
            let speedBoostTimer = 0;

            
            // --- Initialization ---

            /**
             * Sets up the initial state of the application.
             */
            function initializeApp() {
                setupEventListeners();
                highScores = loadHighScores();
                displayHighScores();
                resizeCanvas();
            }

            /**
             * Attaches all necessary event listeners.
             */
            function setupEventListeners() {
                startButton.addEventListener('click', startGame);
                playAgainButton.addEventListener('click', startGame);
                submitScoreButton.addEventListener('click', submitAndSaveHighScore);
                howToPlayButton.addEventListener('click', () => howToPlayModal.classList.remove('hidden'));
                closeModalButton.addEventListener('click', () => howToPlayModal.classList.add('hidden'));
                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('resize', resizeCanvas);
                playerNameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        submitAndSaveHighScore();
                    }
                });
            }

            /**
             * Resizes the canvas to fit the window while maintaining the grid aspect ratio.
             */
            function resizeCanvas() {
                const highscoreSectionWidth = document.getElementById('highscore-section').offsetWidth + 40;
                const availableWidth = window.innerWidth - highscoreSectionWidth;
                const availableHeight = window.innerHeight - 80;
                const size = Math.min(availableWidth, availableHeight);

                canvasSize = Math.floor(size / GRID_SIZE) * GRID_SIZE; // Ensure size is a multiple of GRID_SIZE
                cellSize = canvasSize / GRID_SIZE;

                canvas.width = canvasSize;
                canvas.height = canvasSize;

                // Redraw the game if it's currently running
                if (gameStarted && !gameOver) {
                    draw();
                }
            }


            // --- Game Setup & Core Loop ---
            
            /**
             * Resets all game state variables to start a new game.
             */
            function initGame() {
                level = 1;
                score = 0;
                direction = 'right';
                nextDirection = 'right';
                gameOver = false;
                gameStarted = true;
                obstacles = [];
                snake = [{ x: 10, y: 10 }]; // Start snake in the middle
                currentMoveInterval = BASE_MOVE_INTERVAL;

                updateScoreAndLevelUI();
                spawnFood();

                // Hide overlays
                gameOverScreen.classList.remove('visible');
                startScreen.classList.remove('visible');
                newHighscoreContainer.classList.add('hidden');
            }

            /**
             * Initializes and starts the main game loop.
             */
            function startGame() {
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                }
                initGame();
                lastTime = performance.now();
                gameLoopId = requestAnimationFrame(gameLoop);
            }

            /**
             * The main game loop, driven by requestAnimationFrame.
             * @param {number} currentTime - The current timestamp provided by requestAnimationFrame.
             */
            function gameLoop(currentTime) {
                if (gameOver) return;

                gameLoopId = requestAnimationFrame(gameLoop);
                
                const deltaTime = currentTime - lastTime;
                lastTime = currentTime;
                moveTimer += deltaTime;

                // Handle speed boost countdown
                if (speedBoostTimer > 0) {
                    speedBoostTimer -= deltaTime;
                    if (speedBoostTimer <= 0) {
                        speedBoostTimer = 0;
                        updateMoveInterval(); // Reset speed to normal
                    }
                }

                // Move the snake based on the current interval
                if (moveTimer > currentMoveInterval) {
                    moveTimer %= currentMoveInterval;
                    update();
                    draw();
                }
            }
            
            /**
             * Ends the game, stops the loop, and displays the game over screen.
             */
            function endGame() {
                gameOver = true;
                gameStarted = false;
                cancelAnimationFrame(gameLoopId);
                
                gameOverScreen.classList.add('visible');
                finalScore.textContent = score;

                // Check if the score is a new highscore
                const worstHighScore = highScores.length < MAX_HIGHSCORES ? 0 : highScores[highScores.length - 1].score;
                const isHighScore = score > 0 && score > worstHighScore;

                if (isHighScore) {
                    newHighscoreContainer.classList.remove('hidden');
                    playerNameInput.focus();
                } else {
                    newHighscoreContainer.classList.add('hidden');
                }
            }


            // --- Game Logic & State Updates ---

            /**
             * Updates the game state for a single frame (snake movement, collision, eating).
             */
            function update() {
                direction = nextDirection;
                const head = { ...snake[0] }; // Create a new head object

                // Move head in the current direction
                if (direction === 'right') head.x++;
                if (direction === 'left') head.x--;
                if (direction === 'up') head.y--;
                if (direction === 'down') head.y++;

                // Check for collisions
                if (checkCollision(head)) {
                    endGame();
                    return;
                }

                snake.unshift(head); // Add new head to the front

                // Check for eating food
                if (head.x === food.x && head.y === food.y) {
                    score += food.type.points;
                    
                    // Handle food special actions
                    if (food.type.action === 'speedBoost') {
                        speedBoostTimer = SPEED_BOOST_DURATION;
                        updateMoveInterval();
                    }
                    
                    // Grow the snake
                    const growth = food.type.growth;
                    if (growth > 0) {
                        const tail = snake[snake.length - 1];
                        for (let i = 0; i < growth; i++) {
                            snake.push({ ...tail });
                        }
                    }

                    // Check for level up
                    const newLevel = Math.floor(score / POINTS_PER_LEVEL) + 1;
                    if (newLevel > level) {
                        levelUp(newLevel);
                    }
                    
                    updateScoreAndLevelUI();
                    spawnFood();
                } else {
                    snake.pop(); // Remove tail segment if no food was eaten
                }
            }
            
            /**
             * Handles the logic for leveling up.
             * @param {number} newLevel - The new level number.
             */
            function levelUp(newLevel) {
                level = newLevel;
                updateMoveInterval();
                generateObstacles();
            }

            /**
             * Recalculates the snake's move interval based on level and speed boosts.
             */
            function updateMoveInterval() {
                const baseInterval = BASE_MOVE_INTERVAL - (level - 1) * SPEED_INCREASE_PER_LEVEL;
                let interval = Math.max(MIN_MOVE_INTERVAL, baseInterval);
                
                if (speedBoostTimer > 0) {
                    interval /= 2; // Double the speed
                }
                currentMoveInterval = interval;
            }
            
            /**
             * Checks if the snake's head has collided with anything.
             * @param {object} head - The head segment of the snake ({x, y}).
             * @returns {boolean} - True if a collision occurred, false otherwise.
             */
            function checkCollision(head) {
                // Wall collision
                if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
                    return true;
                }
                // Self collision
                for (let i = 1; i < snake.length; i++) {
                    if (head.x === snake[i].x && head.y === snake[i].y) {
                        return true;
                    }
                }
                // Obstacle collision
                if (isPositionOccupied(head.x, head.y, false)) {
                    return true;
                }
                return false;
            }


            // --- Spawning & Positioning ---

            /**
             * Spawns a new piece of food at a random, unoccupied location.
             */
            function spawnFood() {
                // End game if the board is full
                if (snake.length + obstacles.length >= GRID_SIZE * GRID_SIZE) {
                    endGame();
                    return;
                }
                
                let position;
                do {
                    position = { x: getRandomCoord(), y: getRandomCoord() };
                } while (isPositionOccupied(position.x, position.y) || isTooCloseToObstacle(position.x, position.y, 3));
                
                // Determine food type based on chance
                const rand = Math.random();
                let chosenType;
                if (rand < GRAPE_CHANCE && level >= 3) {
                    chosenType = 'GRAPE';
                } else if (rand < GRAPE_CHANCE + CHERRY_CHANCE) {
                    chosenType = 'CHERRY';
                } else {
                    chosenType = 'APPLE';
                }

                food = { ...position, type: FOOD_TYPES[chosenType] };
            }

            /**
             * Generates new obstacles on the map when leveling up.
             */
            function generateObstacles() {
                for (let i = 0; i < OBSTACLES_PER_LEVEL; i++) {
                    if (snake.length + obstacles.length >= GRID_SIZE * GRID_SIZE) break;
                    let pos;
                    do {
                        pos = { x: getRandomCoord(), y: getRandomCoord() };
                    // Avoid spawning obstacles in the center or on top of existing objects
                    } while (isPositionOccupied(pos.x, pos.y) || (pos.x > 5 && pos.x < 15 && pos.y > 5 && pos.y < 15));
                    obstacles.push(pos);
                }
            }
            
            /**
             * Gets a random coordinate within the grid.
             * @returns {number} - A random integer from 0 to GRID_SIZE - 1.
             */
            function getRandomCoord() {
                return Math.floor(Math.random() * GRID_SIZE);
            }

            /**
             * Checks if a given grid coordinate is occupied by an obstacle or the snake.
             * @param {number} x - The x-coordinate.
             * @param {number} y - The y-coordinate.
             * @param {boolean} [checkSnake=true] - Whether to check for snake body collision.
             * @returns {boolean} - True if the position is occupied.
             */
            function isPositionOccupied(x, y, checkSnake = true) {
                if (obstacles.some((ob) => ob.x === x && ob.y === y)) return true;
                if (checkSnake && snake.some((seg) => seg.x === x && seg.y === y)) return true;
                return false;
            }

            /**
             * Checks if a position is too close to an existing obstacle (for food spawning).
             * @param {number} x - The x-coordinate.
             * @param {number} y - The y-coordinate.
             * @param {number} minDistance - The minimum Manhattan distance allowed.
             * @returns {boolean} - True if the position is too close.
             */
            function isTooCloseToObstacle(x, y, minDistance) {
                for (const ob of obstacles) {
                    const distance = Math.abs(x - ob.x) + Math.abs(y - ob.y);
                    if (distance < minDistance) {
                        return true;
                    }
                }
                return false;
            }


            // --- Drawing ---
            
            /**
             * Draws all game elements (snake, food, obstacles) on the canvas.
             */
            function draw() {
                // Clear canvas with a black background
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvasSize, canvasSize);

                // Draw obstacles
                ctx.fillStyle = OBSTACLE_COLOR;
                obstacles.forEach((ob) => {
                    ctx.fillRect(ob.x * cellSize, ob.y * cellSize, cellSize, cellSize);
                });

                // Draw food emoji
                ctx.font = `${cellSize * 0.9}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(food.type.emoji, food.x * cellSize + cellSize / 2, food.y * cellSize + cellSize / 2.2);

                // Draw snake
                snake.forEach((segment, index) => {
                    ctx.fillStyle = index === 0 ? SNAKE_HEAD_COLOR : SNAKE_BODY_COLOR;
                    ctx.fillRect(segment.x * cellSize, segment.y * cellSize, cellSize, cellSize);
                    ctx.strokeStyle = '#000'; // Add a border to segments
                    ctx.strokeRect(segment.x * cellSize, segment.y * cellSize, cellSize, cellSize);
                });
            }


            // --- Event Handlers & UI ---
            
            /**
             * Handles keyboard input for controlling the snake.
             * @param {KeyboardEvent} e - The keyboard event object.
             */
            function handleKeyDown(e) {
                if (gameOver) return;
                const key = e.key;

                // Prevent the snake from reversing on itself
                if ((key === 'ArrowUp' || key.toLowerCase() === 'w') && direction !== 'down') nextDirection = 'up';
                else if ((key === 'ArrowDown' || key.toLowerCase() === 's') && direction !== 'up') nextDirection = 'down';
                else if ((key === 'ArrowLeft' || key.toLowerCase() === 'a') && direction !== 'right') nextDirection = 'left';
                else if ((key === 'ArrowRight' || key.toLowerCase() === 'd') && direction !== 'left') nextDirection = 'right';
            }

            /**
             * Updates the score and level display in the UI.
             */
            function updateScoreAndLevelUI() {
                scoreValue.textContent = score;
                levelValue.textContent = level;
            }


            // --- High Score Management ---

            /**
             * Loads highscores from localStorage.
             * @returns {Array} - An array of highscore objects, sorted descending.
             */
            function loadHighScores() {
                const scoresJSON = localStorage.getItem(HIGHSCORE_KEY);
                const scores = scoresJSON ? JSON.parse(scoresJSON) : [];
                scores.sort((a, b) => b.score - a.score);
                return scores;
            }

            /**
             * Saves a new highscore to the list and to localStorage.
             * @param {string} name - The player's name.
             * @param {number} score - The player's score.
             */
            function saveHighScore(name, score) {
                const date = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
                const newScore = { name, score, date };
                
                highScores.push(newScore);
                highScores.sort((a, b) => b.score - a.score);
                highScores = highScores.slice(0, MAX_HIGHSCORES); // Keep only top scores
                
                localStorage.setItem(HIGHSCORE_KEY, JSON.stringify(highScores));
            }

            /**
             * Renders the highscore list in the UI.
             */
            function displayHighScores() {
                highscoreList.innerHTML = '';
                if (highScores.length === 0) {
                    const li = document.createElement('li');
                    li.textContent = 'No highscores have been set yet.';
                    li.style.gridTemplateColumns = '1fr'; // Adjust style for single item
                    highscoreList.appendChild(li);
                    return;
                }

                highScores.forEach((entry) => {
                    const li = document.createElement('li');
                    
                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'name';
                    nameSpan.textContent = entry.name;
                    
                    const scoreSpan = document.createElement('span');
                    scoreSpan.className = 'score';
                    scoreSpan.textContent = entry.score;
                    
                    const dateSpan = document.createElement('span');
                    dateSpan.className = 'date';
                    dateSpan.textContent = entry.date;
                    
                    li.appendChild(nameSpan);
                    li.appendChild(scoreSpan);
                    li.appendChild(dateSpan);
                    highscoreList.appendChild(li);
                });
            }
            
            /**
             * Handles the submission of a new highscore from the game over screen.
             */
            function submitAndSaveHighScore() {
                const name = playerNameInput.value.trim().toUpperCase() || 'ANON';
                saveHighScore(name, score);
                displayHighScores();
                newHighscoreContainer.classList.add('hidden');
                playerNameInput.value = '';
            }

            // --- Start the application ---
            initializeApp();
        });
    </script>
</body>
</html>
